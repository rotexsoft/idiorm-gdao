{"name":"Leanorm","tagline":"[WARNING NOT YET PRODUCTION READY: Should be ready in December 2015] A Generic Data Objects (GDAO https://github.com/rotexsoft/gdao ) implementation based on a stripped down (really minimal) version of idiorm.","body":"## Why another PHP ORM (Object-Relational Mapping) Package?\r\nThis package aims to provide only the commonly used data access and manipulation features that most PHP applications need. ORM packages like [Propel](http://propelorm.org/), [Doctrine ORM](http://www.doctrine-project.org/projects/orm.html), [Eloquent](http://laravel.com/docs/5.1/eloquent), etc also provide these features and more features which may never be needed in many PHP applications. LeanOrm's code base is designed to be \r\n* easily comprehensible \r\n* easily extensible (via inheritance or composition) and\r\n* compact (with one Model class, two Record classes (Read-Only and Read-Write), a Collection class, a DBConnector class (that talks to the database via PDO) and a File containing Exception class definitions). \r\n\r\nFor the most part, users of this package will only be interacting with the Model class, one or both of the two Record classes and the Collection class. \r\n\r\nLeanOrm is an implementation of the [Generic Data Objects (GDAO)] (https://github.com/rotexsoft/gdao) package (a package containing an abstract Model class, two interfaces (CollectionInterface and RecordInterface), a RecordList class (a collection data structure that stores only instances of RecordInterface) and a File containing Exception class definitions). The GDAO package was also designed to be compact, easily comprehensible and extensible.\r\n\r\n[Paris] (http://j4mie.github.io/idiormandparis/) is another PHP ORM that adheres to some of the same principles (a compact code-base and easy comprehensibility) as LeanORM. However, the **Active Record** pattern (where records contain data, data access & manipulation logic and business logic) implemented in the Paris package leads to tight coupling of database access and application / business logic. \r\n\r\nLeanOrm implements the [Table Data Gateway](https://en.wikipedia.org/wiki/Table_data_gateway) and [Data Mapper](https://en.wikipedia.org/wiki/Data_mapper_pattern) patterns. This allows for very loose coupling. Business logic dealing with a single row of data in a database table can be put in the Record class for the table in question, business logic dealing with multiple rows of data in a database table can be put in the Collection class for the table in question while database access logic remains in the Model class for the table in question.\r\n\r\nThe Model class generates all the SQL for accessing and manipulating data in the database; it uses the DBConnector class to execute the SQL statements. The Model class together with the DBConnector class act as a Table Data Gateway.\r\n\r\nThe Model class also acts as a Data Mapper by being able to map: \r\n* a row of data in a database table to a Record object \r\n* rows of data in a database table in to a Collection object containing one or more Record objects\r\n* foreign key relationship(s) between database tables into attribute(s) of a record object (an instance of a record per Has-One or Belongs-To relationship and an instance of a collection per Has-Many or Has-Many-Through relationship)\r\n\r\n### Deliberately Omitted Features\r\n* _virtual / calculated columns_,\r\n* _soft deletion_,\r\n* _single table inheritance_, \r\n* _magic fetch methods_ (eg. **fetchBySomeColName**), \r\n* _sanitization & validation_ of data (packages like [Aura Filter](https://github.com/auraphp/Aura.Filter) , [Respect Validate](https://github.com/Respect/Validation) , [Valitron](https://github.com/vlucas/valitron) , etc. can be used),\r\n* _automatic serialization and unserialization_ of database columns, \r\n* _migration_ (packages like [PHPMig](https://github.com/davedevelopment/phpmig) , [Phinx](https://github.com/robmorgan/phinx) , [Migrations](https://github.com/icomefromthenet/Migrations) , etc. can be used)\r\n\r\nCode snippets illustrating how to implement some of the deliberately omitted features will be included in this documentation.\r\n\r\n### Installation & Requirements\r\n* This library requires PHP 5.3 or later. It is currently only installable via composer:\r\n\r\n  `composer require rotexsoft/leanorm`\r\n\r\n* Each table in your database is expected to have a single auto-incrementing numeric primary key column (composite primary keys are not supported).\r\n\r\n### Running tests\r\n  `./vendor/bin/phpunit --coverage-text`\r\n\r\n### Getting Started\r\nLeanOrm will create only one connection to a specific database (ie. one connection per unique dsn string). Creating one or more Model objects for one or more tables with the same dsn string will lead to the creation of only one connection to the database; that one connection will be shared amongst all model instances created with that same dsn string. If you use two different dsn strings, two connections to the database(s) will be created by LeanOrm. Consequently, using three different dsn strings will lead to the creation of three different database connections, and so on for four or more different dsn strings.\r\n\r\nAll examples are based on the schema below:\r\n\r\n![Sample Blog Database Schema](non-autogen-assets/images/blog-db.svg?raw=true)\r\n\r\n### Defining and Creating Model Objects\r\nThere are two basic ways to use this package:\r\n\r\n* Create Model classes for each database table in your application's database. Each of these classes must extend **\\LeanOrm\\Model**. This is the recommended approach for large applications. An example of a Model class (**AuthorsModel**) associated  with an **authors** table in the database:\r\n  ```php\r\n<?php\r\nclass AuthorsModel extends \\LeanOrm\\Model\r\n{\r\n    protected $_collection_class_name = 'AuthorsCollection'; //If not set, \\LeanOrm\\Model\\Collection will be used by default \r\n    protected $_record_class_name = 'AuthorRecord'; //If not set, \\LeanOrm\\Model\\Record will be used by default \r\n\r\n    protected $_created_timestamp_column_name = 'date_created';\r\n    protected $_updated_timestamp_column_name = 'm_timestamp'; \r\n\r\n    protected $_primary_col = 'author_id';\r\n    protected $_table_name = 'authors';\r\n\r\n    protected $_relations = [\r\n        //Entry below specifies that an author can have one or more posts (ie. a has-many relationship).\r\n        'posts' => [\r\n                    'relation_type' => \\LeanOrm\\Model::RELATION_TYPE_HAS_MANY,\r\n\r\n                    'foreign_key_col_in_my_table' => 'author_id',\r\n\r\n                    'foreign_table' => 'posts',\r\n                    'foreign_key_col_in_foreign_table' => 'author_id',\r\n\r\n                    'primary_key_col_in_foreign_table' => 'post_id',\r\n                    'foreign_models_class_name' => 'PostsModel',\r\n                    'foreign_models_collection_class_name' => 'PostsCollection',\r\n                    'foreign_models_record_class_name' => 'PostRecord',\r\n                ]\r\n    ];\r\n}\r\n\r\n//create the model object\r\n$authors_model = new AuthorsModel(\r\n            \"mysql:some-host-name;dbname=blog\",\r\n            \"username\",\r\n            \"password\",\r\n            [PDO::MYSQL_ATTR_INIT_COMMAND => 'SET NAMES utf8']\r\n        );\r\n\r\n?>\r\n  ```\r\n\r\n* Or create instances of **\\LeanOrm\\Model** (one for each database table in your application's database). This approach is good for small to medium sized projects.\r\n  ```php\r\n<?php\r\n\r\n$rel = [\r\n        //Entry below specifies that an author can have one or more posts (ie. a has-many relationship).\r\n        'posts' => [\r\n                    'relation_type' => \\LeanOrm\\Model::RELATION_TYPE_HAS_MANY,\r\n\r\n                    'foreign_key_col_in_my_table' => 'author_id',\r\n\r\n                    'foreign_table' => 'posts',\r\n                    'foreign_key_col_in_foreign_table' => 'author_id',\r\n\r\n                    'primary_key_col_in_foreign_table' => 'post_id',\r\n                    'foreign_models_class_name' => 'PostsModel',\r\n                    'foreign_models_collection_class_name' => 'PostsCollection',\r\n                    'foreign_models_record_class_name' => 'PostRecord',\r\n                ]\r\n    ];\r\n\r\n$authors_model = \r\n        new \\LeanOrm\\Model(\r\n            \"mysql:some-host-name;dbname=blog\",\r\n            \"username\",\r\n            \"password\",\r\n            [PDO::MYSQL_ATTR_INIT_COMMAND => 'SET NAMES utf8'],\r\n            [\r\n            \t\t'primary_col' => 'author_id', \r\n            \t\t'table_name' => 'authors', \r\n            \t\t'relations' => $rel,\r\n            \t\t'created_timestamp_column_name' => 'date_created',\r\n            \t\t'updated_timestamp_column_name' => 'm_timestamp',\r\n            \t\t'collection_class_name' => 'AuthorsCollection', //If not set, \\LeanOrm\\Model\\Collection will be used by default\r\n            \t\t'record_class_name' => 'AuthorRecord', //If not set, \\LeanOrm\\Model\\Record will be used by default \r\n            ]\r\n        );\r\n?>\r\n  ```\r\n\r\n> For both methods, you can decide if you want to use the base Record and Collection classes (**\\LeanOrm\\Model\\Collection** and **\\LeanOrm\\Model\\Record** (or **\\LeanOrm\\Model\\ReadOnlyRecord** if needed) ) or if you want to extend the base Record and Collection classes eg:\r\n\r\n  ```php\r\n<?php\r\nclass AuthorsCollection extends \\LeanOrm\\Model\\Collection {\r\n   //some custom code for collection objects that are meant to hold records belonging to the 'authors' database table\r\n}\r\n\r\nclass AuthorRecord extends \\LeanOrm\\Model\\Record {\r\n   //some custom code for records belonging to the 'authors' database table\r\n}\r\n?>\r\n  ```\r\n\r\n### Creating Records & Inserting Data into the Database\r\n\r\n  ```php\r\n<?php\r\n    //Method 1:\r\n    $new_record = $authors_model->createNewRecord(); //create a blank new record\r\n    $new_record->name = 'Joe Blow'; //set a value for the 'name' column\r\n    $new_record->save();//save to the database\r\n    \r\n    //Method 2:\r\n    //create a new record and set a value for the 'name' column\r\n    $new_record = $authors_model->createNewRecord([ 'name' => 'Joe Blow']); \r\n    $new_record->save();//save to the database\r\n\r\n    //NOTE: createNewRecord also accepts a second parameter, an associative array\r\n    //      that can be used to supply values for the properties of the record\r\n    //      object to be created. \r\n    //      Eg. $authors_model->createNewRecord([ 'name' => 'Joe Blow'], ['_is_new'=>false ])\r\n    //      that is marked as not new by setting the _is_new property of the Record object\r\n    //      that was created to false.\r\n\r\n    //Method 3:\r\n    //$inserted_data is an associative array of the data just inserted into the \r\n    //database. This data will include an auto-generated primary key value and \r\n    //values of the columns that keep track of the time the record was inserted \r\n    //and last updated (if the $_created_timestamp_column_name and \r\n    //$_updated_timestamp_column_name were correctly set).\r\n    $inserted_data = $authors_model->insert([ 'name' => 'Joe Blow']);\r\n    \r\n    //Multiple Inserts:\r\n    //Below is the most efficient way insert multiple rows to the database.\r\n    //$all_successfully_inserted will be === true if all the inserts were\r\n    //successful, otherwise it will be  === false which means the multiple\r\n    //insert was unsuccessful (nothing is saved to the database in this case).\r\n    $all_successfully_inserted = $authors_model->insertMany([ ['name' => 'Joe Blow'], ['name' => 'Jane Doe'] ]);\r\n    \r\n    //NOTE: if you have a collection (an instance of \\LeanOrm\\Model\\Collection) \r\n    //      containing 2 or more records you can also efficiently save the records \r\n    //      by calling \\LeanOrm\\Model\\Collection::saveAll(true). See the documentation\r\n    //      for Collections for more details.\r\n?>\r\n  ```\r\n\r\n### Fetching data from the Database - Parameter Definition\r\n\r\nThere are eight Model methods for fetching data from the database:\r\n* _**fetchCol(array $params = array()):**_\r\n\r\n  > selects data from a single database table's column and returns an array of the column values.\r\n\r\n* _**fetchOneRecord(array $params = array()):**_\r\n\r\n  > selects a single row of data from a database table and returns it as an instance of \\LeanOrm\\Model\\Record (or any of its subclasses).\r\n\r\n* _**fetchPairs(array $params = array()):**_\r\n\r\n  > selects data from two database table columns and returns an array whose keys are values from the first column and whose values are the values from the second column.\r\n\r\n* _**fetch($ids, array $params=array(), $use_records=false, $use_collections=false):**_\r\n\r\n  > selects one row of data from a database table if `$ids` contains an integer value matching the primary key value of a row in the database table (returns it as an instance of \\LeanOrm\\Model\\Record). Selects one or more rows of data from a database table if `$ids` is an array of integer values matching the primary key values of one or more rows of data from a database table and returns them as instances of \\LeanOrm\\Model\\Record (or any of its subclasses) inside an array or an instance of \\LeanOrm\\Model\\Collection (or any of its subclasses) or returns them as an array of arrays.\r\n\r\n* _**fetchRecordsIntoArray(array $params = array()):**_\r\n\r\n  > selects one or more rows of data from a database table and returns them as instances of \\LeanOrm\\Model\\Record (or any of its subclasses) inside an array.\r\n\r\n* _**fetchRecordsIntoCollection(array $params = array()):**_\r\n\r\n  > selects one or more rows of data from a database table and returns them as instances of \\LeanOrm\\Model\\Record (or any of its subclasses) inside an instance of \\LeanOrm\\Model\\Collection (or any of its subclasses).\r\n\r\n* _**fetchRowsIntoArray(array $params = array()):**_\r\n\r\n  > selects one or more rows of data from a database table and returns them as associative arrays inside an array.\r\n\r\n* _**fetchValue(array $params = array()):**_\r\n\r\n  > selects a single value from a single column of a single row of data from a database table and returns the value (eg. as a string, or an appropriate data type). \r\n\r\nThey all accept one parameter; an associative array (**$params**) for specifying how the data should be retrieved (except for _**fetch(..)**_ which accepts additional parameters). Below is the specification for the structure of the array:\r\n\r\n* **relations_to_include**: this entry in the **$params** array should contain an array of relation names defined for a specific model. For example, the definition below would be valid for the AuthorsModel defined earlier in this document:\r\n\r\n  > _**$params=[\"relations_to_include\"=>['posts']];**_\r\n\r\n* **distinct**: this entry in the **$params** array should contain a boolean value of **true** if the **DISTINCT** keyword should be added to the SELECT statement that will be generated by the fetch method to fetch data or **false** if the **DISTINCT** keyword should be ommitted. For example, the definition below would be valid for the AuthorsModel defined earlier in this document:\r\n\r\n  > _**$params=[\"distinct\"=>true];**_\r\n\r\n* **cols**: this entry in the **$params** array should contain an array of the name(s) of column(s) to be returned in the data returned by the fetch method. If this entry is not set in the **$params** array, all columns will be returned in the result of the fetch method if applicable. For example, the definition below would be valid for the AuthorsModel defined earlier in this document:\r\n\r\n  > _**$params=[\"cols\"=>['author_id', 'name']];**_\r\n\r\n* **where**: this entry in the **$params** array should contain an array of parameters for building a WHERE clause to be added to the SELECT statement that will be generated by the fetch method to fetch data. For example, the definitions below would be valid for the AuthorsModel defined earlier in this document:\r\n\r\n  ```php\r\n<?php\r\n    $params = [\r\n        'where' => \r\n            [\r\n                [ 'col'=>'name', 'op'=>'=', 'val'=>'Joe Blow' ],\r\n                [ 'col'=>'author_id', 'op'=>'>', 'val'=>2 ],\r\n                [ 'col'=>'date_created', 'op'=>'>=', 'val'=>'2015-08-19 14:24:48' ],\r\n            ]\r\n    ];\r\n\r\n    //Generates the WHERE clause below:\r\n    /*\r\n        WHERE\r\n        (\r\n            name = 'Joe Blow' \r\n            AND author_id > '2' \r\n            AND date_created >= '2015-08-19 14:24:48' \r\n        )\r\n    */\r\n\r\n    $params = [\r\n        'where' => \r\n            [\r\n                [\r\n                    [ 'col'=>'name', 'op'=>'=', 'val'=>'Joe Blow' ],\r\n                    [ 'col'=>'author_id', 'op'=>'>', 'val'=>2 ],\r\n                ],\r\n                'OR'=> [\r\n                           [ 'col'=>'name', 'op'=>'!=', 'val'=>'Joe Blow' ],\r\n                           [ 'col'=>'author_id', 'op'=>'<', 'val'=>50 ]\r\n                       ],\r\n                [ 'col'=>'date_created', 'op'=>'>=', 'val'=>'2015-08-19 14:24:48' ],\r\n                'OR#2'=> [\r\n                            [ 'col'=>'name', 'op'=>'=', 'val'=>'Jane Doe' ],\r\n                            [ 'col'=>'author_id', 'op'=>'not-in', 'val'=>[58, 65] ],\r\n                         ]\r\n            ]\r\n    ];\r\n    \r\n    //Generates the WHERE clause below:\r\n    /*\r\n    WHERE\r\n        (\r\n            (\r\n                name = 'Joe Blow' \r\n                AND author_id > 2 \r\n            )\r\n            OR\r\n            (\r\n                name <> 'Joe Blow' \r\n                AND author_id > 50\r\n            )\r\n            AND date_created >= '2015-08-19 14:24:48' \r\n            OR\r\n            (\r\n                name = 'Jane Doe' \r\n                AND author_id NOT IN  (58,65)  \r\n            )\r\n        )\r\n    */\r\n\r\n    // NOTE 1: The 'op' could be assigned any one of these values:\r\n    // '=', '>', '>=', '<', '<=', 'in', 'is-null', 'like', '!=', 'not-in', 'not-like', 'not-null'\r\n\r\n    // NOTE 2: For multiple OR conditions, append a # and a unique string after \r\n    // the # to the OR key so that the subsequent OR condition(s) do not override  \r\n    // the previous ones. \r\n\r\n    // NOTE 3: Do not to make the first key in the 'where' array or the first key \r\n    // in any of the array(s) inside the 'where' array an 'OR' or 'OR#...' key.\r\n\r\n    // NOTE 4: For any sub-array containing an item with a key named 'op' with a \r\n    // value of either 'not-null' or 'is-null', there must not be any item in that \r\n    // sub-array with a key named 'val', but there must be a corresponding item \r\n    // with a key named 'col' with a string value.\r\n    \r\n    // NOTE 5: The operators: 'in' and 'not-in' allow 'val' to be set to an array \r\n    // or string value. If 'val' is a string, it must be a valid value that a \r\n    // NOT IN or IN operator expects including the opening and closing brackets. \r\n    // Eg. \"( 1, 2, 3 )\" or \"( '4', '5', '6' )\".\r\n?>\r\n  ```\r\n\r\n* **group**: this entry in the **$params** array should contain an array of the name(s) of column(s) for building a GROUP BY clause to be added to the SELECT statement that will be generated by the fetch method to fetch data. For example, the definition below would be valid for the AuthorsModel defined earlier in this document:\r\n\r\n  > _**$params=['group' => ['name']];**_ generates _**GROUP BY name**_\r\n\r\n\r\n* **having**: this entry in the **$params** array should contain an array of parameters for building a HAVING clause to be added to the SELECT statement that will be generated by the fetch method to fetch data. For example, the definitions below would be valid for the AuthorsModel defined earlier in this document:\r\n\r\n  ```php\r\n<?php\r\n    $params = [\r\n        'having' => \r\n            [\r\n                [ 'col'=>'name', 'op'=>'=', 'val'=>'Joe Blow' ],\r\n                [ 'col'=>'author_id', 'op'=>'>', 'val'=>2 ],\r\n                [ 'col'=>'date_created', 'op'=>'>=', 'val'=>'2015-08-19 14:24:48' ],\r\n            ]\r\n    ];\r\n\r\n    //Generates the HAVING clause below:\r\n    /*\r\n        HAVING\r\n        (\r\n            name = 'Joe Blow' \r\n            AND author_id > '2' \r\n            AND date_created >= '2015-08-19 14:24:48' \r\n        )\r\n    */\r\n\r\n    $params = [\r\n        'having' => \r\n            [\r\n                [\r\n                    [ 'col'=>'name', 'op'=>'=', 'val'=>'Joe Blow' ],\r\n                    [ 'col'=>'author_id', 'op'=>'>', 'val'=>2 ],\r\n                ],\r\n                'OR'=> [\r\n                           [ 'col'=>'name', 'op'=>'!=', 'val'=>'Joe Blow' ],\r\n                           [ 'col'=>'author_id', 'op'=>'<', 'val'=>50 ]\r\n                       ],\r\n                [ 'col'=>'date_created', 'op'=>'>=', 'val'=>'2015-08-19 14:24:48' ],\r\n                'OR#2'=> [\r\n                            [ 'col'=>'name', 'op'=>'=', 'val'=>'Jane Doe' ],\r\n                            [ 'col'=>'author_id', 'op'=>'not-in', 'val'=>[58, 65] ],\r\n                         ]\r\n            ]\r\n    ];\r\n    \r\n    //Generates the HAVING clause below:\r\n    /*\r\n    HAVING\r\n        (\r\n            (\r\n                name = 'Joe Blow' \r\n                AND author_id > 2 \r\n            )\r\n            OR\r\n            (\r\n                name <> 'Joe Blow' \r\n                AND author_id > 50\r\n            )\r\n            AND date_created >= '2015-08-19 14:24:48' \r\n            OR\r\n            (\r\n                name = 'Jane Doe' \r\n                AND author_id NOT IN  (58,65)  \r\n            )\r\n        )\r\n    */\r\n\r\n    // NOTE 1: The 'op' could be assigned any one of these values:\r\n    // '=', '>', '>=', '<', '<=', 'in', 'is-null', 'like', '!=', 'not-in', 'not-like', 'not-null'\r\n\r\n    // NOTE 2: For multiple OR conditions, append a # and a unique string after \r\n    // the # to the OR key so that the subsequent OR condition(s) do not override  \r\n    // the previous ones. \r\n\r\n    // NOTE 3: Do not to make the first key in the 'having' array or the first key \r\n    // in any of the array(s) inside the 'having' array an 'OR' or 'OR#...' key.\r\n\r\n    // NOTE 4: For any sub-array containing an item with a key named 'op' with a \r\n    // value of either 'not-null' or 'is-null', there must not be any item in that \r\n    // sub-array with a key named 'val', but there must be a corresponding item \r\n    // with a key named 'col' with a string value.\r\n    \r\n    // NOTE 5: The operators: 'in' and 'not-in' allow 'val' to be set to an array \r\n    // or string value. If 'val' is a string, it must be a valid value that a \r\n    // NOT IN or IN operator expects including the opening and closing brackets. \r\n    // Eg. \"( 1, 2, 3 )\" or \"( '4', '5', '6' )\".\r\n?>\r\n  ```\r\n* **order**: this entry in the **$params** array should contain an array of parameters for building an ORDER BY clause to be added to the SELECT statement that will be generated by the fetch method to fetch data. For example, the definition below would be valid for the AuthorsModel defined earlier in this document:\r\n\r\n  > _**$params = [ 'order' => ['name DESC'] ];**_ generates _**ORDER BY name DESC**_\r\n\r\n* **limit_size**: this entry in the **$params** array should contain an int value for building a LIMIT clause to be added to the SELECT statement that will be generated by the fetch method to fetch data. For example, the definition below would be valid for the AuthorsModel defined earlier in this document:\r\n\r\n  > _**$params = [ 'limit_size'=>50 ];**_ generates _**LIMIT 50**_ for a mysql database. It would be different for MS SQLServer.\r\n\r\n* **limit_offset**: this entry in the **$params** array should contain an int value for building the OFFSET part of the LIMIT clause to be added to the SELECT statement that will be generated by the fetch method to fetch data. It has no effect when **limit_size** has not been set. For example, the definition below would be valid for the AuthorsModel defined earlier in this document:\r\n\r\n  > _**$params = [ 'limit_offset' => 10, 'limit_size'=>50 ];**_ generates _**LIMIT 50 OFFSET 10**_ for a mysql database. It would be different for MS SQLServer (ie. _**OFFSET 10 ROWS FETCH NEXT 50 ROWS ONLY**_).\r\n\r\n### Fetching data from the Database - Data Retreival\r\n\r\n* **Fetching one or more rows of data (via fetch):**\r\n  ```php\r\n<?php\r\n    $params = [\r\n        \"cols\"=>['author_id', 'name', 'date_created'],\r\n    ];\r\n\r\n    //The $params array above causes $authors_model->fetch(2, $params) to generate the SQL \r\n    //statement below:\r\n    /*\r\n        SELECT author_id, name, date_created\r\n          FROM `authors`\r\n         WHERE\r\n            (\r\n                author_id = 2\r\n            );\r\n    */\r\n\r\n    //The call below fetches a database table row having an author_id value of 2 \r\n    //into an instance of AuthorRecord which is a sub-class of \\LeanOrm\\Model\\Record.\r\n    $author_record = $authors_model->fetch(2, $params);\r\n\r\n    //You can access the fetched data like so using object notation:\r\n    echo \" author_id: {$author_record->author_id}, name: {$author_record->name} , date_created: {$author_record->date_created} <br>\";\r\n\r\n    //You can access the fetched data like so using array syntax:\r\n    echo \" author_id: {$author_record['author_id']}, name: {$author_record['name']} , date_created: {$author_record['date_created']} <br>\";\r\n    \r\n    //To return related data (if any) defined in the Model's _relations array,\r\n    //add a 'relations_to_include' entry to the $params array defined ealier\r\n    //above. For example, to get the posts belonging to an author (note that\r\n    //this relationship has been defined in the AuthorsModel class earlier\r\n    //above) modify the $params array like so:\r\n    $params['relations_to_include'] = ['posts'];\r\n    $author_record = $authors_model->fetch(2, $params);\r\n\r\n    //You can access the fetched data like so using object notation:\r\n    echo \" author_id: {$author_record->author_id}, name: {$author_record->name} , date_created: {$author_record->date_created} <br>\";\r\n\r\n    //Access the posts\r\n    echo \" Posts: <br>\";\r\n\r\n    //In this case, $author_record->posts will be an instance of PostsCollection\r\n    //and each $post_record will be an instance of PostRecord based on the \r\n    //relationship definintion in the AuthorsModel class.\r\n\r\n    foreach($author_record->posts as $post_record) {\r\n\r\n        echo \" post_id: {$post_record->post_id}, title: {$post_record->title} , body: {$post_record->body} <br>\";\r\n    }\r\n\r\n    //You can fetch a collection of AuthorRecord(s) with author_id values of 1, 2 and 3 via \r\n    //the call below:\r\n    $authors_model->fetch( [1, 2, 3], $params, true, true);\r\n\r\n    //You can fetch an array of AuthorRecord(s) with author_id values of 1, 2 and 3 via \r\n    //the call below:\r\n    $authors_model->fetch( [1, 2, 3], $params, true, false);\r\n\r\n    //You can fetch an array of rows in the authors table with author_id values of 1, 2 and 3 via \r\n    //the call below:\r\n    $authors_model->fetch( [1, 2, 3], $params, false, false);\r\n?>\r\n  ```\r\n\r\n* **Fetching data as Records into a Collection (via fetchRecordsIntoCollection):**\r\n\r\n  ```php\r\n<?php\r\n    $params = [\r\n        \"distinct\"=>true,\r\n        \"cols\"=>['author_id', 'name', 'date_created'],\r\n        'where' =>  [\r\n                        [ 'col'=>'name', 'op'=>'=', 'val'=>'Joe Blow' ],\r\n                        [ 'col'=>'author_id', 'op'=>'>', 'val'=>2 ],\r\n                        [ 'col'=>'date_created', 'op'=>'>=', 'val'=>'2015-08-19 14:24:48' ],\r\n                    ],\r\n        'group' => ['name'],\r\n        'having'=>  [\r\n                        [ 'col'=>'date_created', 'op'=>'>=', 'val'=>'2015-08-19 14:24:48' ],\r\n                    ],\r\n        'order' => ['name DESC'],\r\n        'limit_offset' => 0,\r\n        'limit_size' => 50,\r\n    ];\r\n    \r\n    //The $params array above causes any of the fetch* methods to generate the SQL \r\n    //statement below (which would be used by the fetch* method to retrieve data from the database):\r\n    /*\r\n        SELECT DISTINCT author_id, name, date_created\r\n        FROM\r\n            `authors`\r\n        WHERE\r\n            (\r\n                name = 'Joe Blow' \r\n                AND author_id > 2 \r\n                AND date_created >= '2015-08-19 14:24:48'\r\n            )\r\n        GROUP BY name\r\n        HAVING\r\n            (\r\n                date_created >= '2015-08-19 14:24:48' \r\n            )\r\n        ORDER BY name DESC\r\n        LIMIT 50;\r\n    */\r\n    \r\n    //The fetchRecordsIntoCollection call below returns an instance \r\n    //of \\LeanOrm\\Model\\Collection containing one or more instances of\r\n    //\\LeanOrm\\Model\\Record each containing a row of data from the row(s)\r\n    //returned by executing the generated select query above.\r\n    $collection_of_authors = $authors_model->fetchRecordsIntoCollection($params);\r\n    \r\n    //You can loop through the collection like so:\r\n    foreach ($collection_of_authors as $collection_key => $author_record) {\r\n        \r\n        echo \" author_id: {$author_record->author_id}, name: {$author_record->name} , date_created: {$author_record->date_created} <br>\";\r\n        \r\n        //Accessing a database table's columns in a record object using array syntax also works like below:\r\n        echo \" author_id: {$author_record['author_id']}, name: {$author_record['name']} , date_created: {$author_record['date_created']} <br>\";\r\n    }\r\n\r\n    //To return all the rows in a database table, call fetchRecordsIntoCollection with \r\n    //no parameters. In this case fetchRecordsIntoCollection will just perform a \r\n    //\"SELECT authors.* FROM `authors`\" query and return all the rows of data in\r\n    //the authors table.\r\n    $collection_of_all_authors = $authors_model->fetchRecordsIntoCollection();\r\n\r\n    //To return related data (if any) defined in the Model's _relations array,\r\n    //add a 'relations_to_include' entry to the $params array defined ealier\r\n    //above. For example, to get the posts belonging to an author (note that\r\n    //this relationship has been defined in the AuthorsModel class earlier\r\n    //above) modify the $params array like so:\r\n    $params['relations_to_include'] = ['posts'];\r\n    $collection_of_authors_with_posts = $authors_model->fetchRecordsIntoCollection($params);\r\n    \r\n    //You can loop through the collection like so:\r\n    foreach ($collection_of_authors_with_posts as $collection_key => $author_record) {\r\n        \r\n        echo \" author_id: {$author_record->author_id}, name: {$author_record->name} , date_created: {$author_record->date_created} <br>\";\r\n        \r\n        //Access the posts\r\n        echo \" Posts: <br>\";\r\n\r\n        //In this case, $author_record->posts will be an instance of PostsCollection\r\n        //and each $post_record will be an instance of PostRecord based on the \r\n        //relationship definintion in the AuthorsModel class.\r\n\r\n        foreach($author_record->posts as $post_record) {\r\n            \r\n            echo \" post_id: {$post_record->post_id}, title: {$post_record->title} , body: {$post_record->body} <br>\";\r\n        }\r\n    }\r\n?>\r\n  ```\r\n\r\n* **Fetching data as Records into an array (via fetchRecordsIntoArray ):** Use this method if you don't need to call any of the Collection methods on the returned data. **fetchRecordsIntoArray** executes slightly faster than **fetchRecordsIntoCollection** and is also slightly more memory efficient than **fetchRecordsIntoCollection**.\r\n  ```php\r\n<?php\r\n    $params = [\r\n        \"distinct\"=>true,\r\n        \"cols\"=>['author_id', 'name', 'date_created'],\r\n        'where' =>  [\r\n                        [ 'col'=>'name', 'op'=>'=', 'val'=>'Joe Blow' ],\r\n                        [ 'col'=>'author_id', 'op'=>'>', 'val'=>2 ],\r\n                        [ 'col'=>'date_created', 'op'=>'>=', 'val'=>'2015-08-19 14:24:48' ],\r\n                    ],\r\n        'group' => ['name'],\r\n        'having'=>  [\r\n                        [ 'col'=>'date_created', 'op'=>'>=', 'val'=>'2015-08-19 14:24:48' ],\r\n                    ],\r\n        'order' => ['name DESC'],\r\n        'limit_offset' => 0,\r\n        'limit_size' => 50,\r\n    ];\r\n\r\n    //The $params array above causes any of the fetch* methods to generate the SQL \r\n    //statement below (which would be used by the fetch* method to retrieve data from the database):\r\n    /*\r\n        SELECT DISTINCT author_id, name, date_created\r\n        FROM\r\n            `authors`\r\n        WHERE\r\n            (\r\n                name = 'Joe Blow' \r\n                AND author_id > 2 \r\n                AND date_created >= '2015-08-19 14:24:48'\r\n            )\r\n        GROUP BY name\r\n        HAVING\r\n            (\r\n                date_created >= '2015-08-19 14:24:48' \r\n            )\r\n        ORDER BY name DESC\r\n        LIMIT 50;\r\n    */\r\n\r\n    //The fetchRecordsIntoArray call below returns an array containing one or more \r\n    //instances of \\LeanOrm\\Model\\Record each containing a row of data from the \r\n    //row(s) returned by executing the generated select query above.\r\n    $array_of_author_records = $authors_model->fetchRecordsIntoArray($params);\r\n\r\n    //You can loop through the array like so:\r\n    foreach ($array_of_author_records as $array_key => $author_record) {\r\n\r\n        echo \" author_id: {$author_record->author_id}, name: {$author_record->name} , date_created: {$author_record->date_created} <br>\";\r\n\r\n        //Accessing a database table's columns in a record object using array syntax also works like below:\r\n        echo \" author_id: {$author_record['author_id']}, name: {$author_record['name']} , date_created: {$author_record['date_created']} <br>\";\r\n    }\r\n\r\n    //To return all the rows in a database table, call fetchRecordsIntoArray with \r\n    //no parameters. In this case fetchRecordsIntoArray will just perform a \r\n    //\"SELECT authors.* FROM `authors`\" query and return all the rows of data in\r\n    //the authors table.\r\n    $array_of_all_author_records = $authors_model->fetchRecordsIntoArray();\r\n\r\n    //To return related data (if any) defined in the Model's _relations array,\r\n    //add a 'relations_to_include' entry to the $params array defined ealier\r\n    //above. For example, to get the posts belonging to an author (note that\r\n    //this relationship has been defined in the AuthorsModel class earlier\r\n    //above) modify the $params array like so:\r\n    $params['relations_to_include'] = ['posts'];\r\n    $array_of_authors_with_posts = $authors_model->fetchRecordsIntoArray($params);\r\n\r\n    //You can loop through the array like so:\r\n    foreach ($array_of_authors_with_posts as $array_key => $author_record) {\r\n\r\n        echo \" author_id: {$author_record->author_id}, name: {$author_record->name} , date_created: {$author_record->date_created} <br>\";\r\n\r\n        //Access the posts\r\n        echo \" Posts: <br>\";\r\n\r\n        //In this case, $author_record->posts will be an array.\r\n        //Each $post_record will be an instance of PostRecord based on the \r\n        //relationship definintion in the AuthorsModel class.\r\n\r\n        foreach($author_record->posts as $post_record) {\r\n\r\n            echo \" post_id: {$post_record->post_id}, title: {$post_record->title} , body: {$post_record->body} <br>\";\r\n        }\r\n    }\r\n?>\r\n  ```\r\n\r\n* **Fetching data as arrays into an array (via fetchRowsIntoArray ):** Use this method if you don't need to call any of the Collection or Record methods on the returned data. **fetchRowsIntoArray** executes faster than **fetchRecordsIntoArray** and **fetchRecordsIntoCollection** and is also more memory efficient than **fetchRecordsIntoArray** and **fetchRecordsIntoCollection**.\r\n  ```php\r\n<?php\r\n    $params = [\r\n        \"distinct\"=>true,\r\n        \"cols\"=>['author_id', 'name', 'date_created'],\r\n        'where' =>  [\r\n                        [ 'col'=>'name', 'op'=>'=', 'val'=>'Joe Blow' ],\r\n                        [ 'col'=>'author_id', 'op'=>'>', 'val'=>2 ],\r\n                        [ 'col'=>'date_created', 'op'=>'>=', 'val'=>'2015-08-19 14:24:48' ],\r\n                    ],\r\n        'group' => ['name'],\r\n        'having'=>  [\r\n                        [ 'col'=>'date_created', 'op'=>'>=', 'val'=>'2015-08-19 14:24:48' ],\r\n                    ],\r\n        'order' => ['name DESC'],\r\n        'limit_offset' => 0,\r\n        'limit_size' => 50,\r\n    ];\r\n\r\n    //The $params array above causes any of the fetch* methods to generate the SQL \r\n    //statement below (which would be used by the fetch* method to retrieve data from the database):\r\n    /*\r\n        SELECT DISTINCT author_id, name, date_created\r\n        FROM\r\n            `authors`\r\n        WHERE\r\n            (\r\n                name = 'Joe Blow' \r\n                AND author_id > 2 \r\n                AND date_created >= '2015-08-19 14:24:48'\r\n            )\r\n        GROUP BY name\r\n        HAVING\r\n            (\r\n                date_created >= '2015-08-19 14:24:48' \r\n            )\r\n        ORDER BY name DESC\r\n        LIMIT 50;\r\n    */\r\n\r\n    //The fetchRowsIntoArray call below returns an array containing one or more \r\n    //array(s) each containing a row of data from the row(s) returned by \r\n    //executing the generated select query above.\r\n    $array_of_authors = $authors_model->fetchRowsIntoArray($params);\r\n\r\n    //You can loop through the array like so:\r\n    foreach ($array_of_authors as $array_key => $array_of_author_data) {\r\n\r\n        echo \" author_id: {$array_of_author_data['author_id']}, name: {$array_of_author_data['name']} , date_created: {$array_of_author_data['date_created']} <br>\";\r\n    }\r\n\r\n    //To return all the rows in a database table, call fetchRowsIntoArray with \r\n    //no parameters. In this case fetchRowsIntoArray will just perform a \r\n    //\"SELECT authors.* FROM `authors`\" query and return all the rows of data in\r\n    //the authors table.\r\n    $array_of_all_authors = $authors_model->fetchRowsIntoArray();\r\n\r\n    //To return related data (if any) defined in the Model's _relations array,\r\n    //add a 'relations_to_include' entry to the $params array defined ealier\r\n    //above. For example, to get the posts belonging to an author (note that\r\n    //this relationship has been defined in the AuthorsModel class earlier\r\n    //above) modify the $params array like so:\r\n    $params['relations_to_include'] = ['posts'];\r\n    $array_of_authors_with_posts = $authors_model->fetchRowsIntoArray($params);\r\n\r\n    //You can loop through the array like so:\r\n    foreach ($array_of_authors_with_posts as $array_key => $array_of_author_data) {\r\n\r\n        echo \" author_id: {$array_of_author_data['author_id']}, name: {$array_of_author_data['name']} , date_created: {$array_of_author_data['date_created']} <br>\";\r\n\r\n        //Access the posts\r\n        echo \" Posts: <br>\";\r\n\r\n        //In this case, $array_of_author_data['posts'] will be an array.\r\n        //Each $post_record will be an array containing a row of data from the\r\n        //posts database table. The related data is retrieved based on the relationship \r\n        //definintion in the AuthorsModel class.\r\n\r\n        foreach($array_of_author_data['posts'] as $post_record) {\r\n\r\n            echo \" post_id: {$post_record['post_id']}, title: {$post_record['title']} , body: {$post_record['body']} <br>\";\r\n        }\r\n    }\r\n?>\r\n  ```\r\n\r\n* **Fetching one row of data as a Record (via fetchOneRecord):**\r\n  ```php\r\n<?php\r\n    $params = [\r\n        \"cols\"=>['author_id', 'name', 'date_created'],\r\n        'where' =>  [\r\n                        [ 'col'=>'author_id', 'op'=>'=', 'val'=>2 ],\r\n                    ],\r\n    ];\r\n\r\n    //The $params array above causes any of the fetch* methods to generate the SQL \r\n    //statement below (which would be used by the fetch* method to retrieve data from the database):\r\n    /*\r\n        SELECT author_id, name, date_created\r\n          FROM `authors`\r\n         WHERE\r\n            (\r\n                author_id = 2\r\n            );\r\n    */\r\n\r\n    //fetchOneRecord returns an instance of \\LeanOrm\\Model\\Record from the first \r\n    //row returned by executing the generated select query above. \r\n    //In this case the first database table row having an author_id value of 2 is \r\n    //returned as an instance of AuthorRecord which is a sub-class of\r\n    //\\LeanOrm\\Model\\Record because the _record_class_name property of the\r\n    //AuthorsModel class was set to 'AuthorRecord'.\r\n    $author_record = $authors_model->fetchOneRecord($params);\r\n\r\n    //You can access the fetched data like so using object notation:\r\n    echo \" author_id: {$author_record->author_id}, name: {$author_record->name} , date_created: {$author_record->date_created} <br>\";\r\n\r\n    //You can access the fetched data like so using array syntax:\r\n    echo \" author_id: {$author_record['author_id']}, name: {$author_record['name']} , date_created: {$author_record['date_created']} <br>\";\r\n    \r\n    //Calling fetchOneRecord with no parameters returns an instance of \r\n    //\\LeanOrm\\Model\\Record from the first row returned by executing \r\n    //\"SELECT authors.* FROM `authors`\". In this case an instance of \r\n    //AuthorRecord is returned.\r\n    $author_record = $authors_model->fetchOneRecord();\r\n\r\n    //To return related data (if any) defined in the Model's _relations array,\r\n    //add a 'relations_to_include' entry to the $params array defined ealier\r\n    //above. For example, to get the posts belonging to an author (note that\r\n    //this relationship has been defined in the AuthorsModel class earlier\r\n    //above) modify the $params array like so:\r\n    $params['relations_to_include'] = ['posts'];\r\n    $author_record = $authors_model->fetchOneRecord($params);\r\n\r\n    //You can access the fetched data like so using object notation:\r\n    echo \" author_id: {$author_record->author_id}, name: {$author_record->name} , date_created: {$author_record->date_created} <br>\";\r\n\r\n    //Access the posts\r\n    echo \" Posts: <br>\";\r\n\r\n    //In this case, $author_record->posts will be an instance of PostsCollection\r\n    //and each $post_record will be an instance of PostRecord based on the \r\n    //relationship definintion in the AuthorsModel class.\r\n\r\n    foreach($author_record->posts as $post_record) {\r\n\r\n        echo \" post_id: {$post_record->post_id}, title: {$post_record->title} , body: {$post_record->body} <br>\";\r\n    }\r\n?>\r\n  ```\r\n\r\n* **Fetching data from two database table columns into an array (via fetchPairs), where values from the first column will be the keys in the returned array and the values from the second column will be the corresponding values in the returned array:**\r\n  ```php\r\n<?php\r\n    $params = [\r\n        \"cols\"=>['author_id', 'name', 'date_created'],\r\n        'where' =>  [\r\n                        [ 'col'=>'author_id', 'op'=>'in', 'val'=>[1,3] ],\r\n                    ],\r\n    ];\r\n\r\n    //The $params array above causes any of the fetch* methods to generate the SQL \r\n    //statement below (which would be used by the fetch* method to retrieve data from the database):\r\n    /*\r\n        SELECT author_id, name, date_created\r\n          FROM `authors`\r\n         WHERE\r\n            (\r\n                author_id IN  (1,3)\r\n            );\r\n\r\n        ---------------------------------------------------------------------------\r\n        | author_id |     name    |       m_timestamp     |   date_created        |\r\n        ---------------------------------------------------------------------------\r\n        |     1     | 'Joe Blow'  | '2015-08-19 14:24:48' | '2015-08-19 14:24:48' |\r\n        ---------------------------------------------------------------------------\r\n        |     2     | 'Jack Doe'  | '2015-08-19 14:24:48' | '2015-08-19 14:24:48' |\r\n        ---------------------------------------------------------------------------\r\n        |     3     | 'Jane Doe'  | '2015-08-19 14:24:48' | '2015-08-19 14:24:48' |\r\n        ---------------------------------------------------------------------------\r\n      \r\n        Given an authors database table containing the data above calling fetchPairs \r\n        like below will return [ 1=>'Joe Blow', 3=>'Jane Doe'] \r\n        (NOTE: it uses the first two columns in $params['cols']):\r\n     */\r\n    $data = $authors_model->fetchPairs($params);\r\n\r\n    /*\r\n        Given an authors database table containing the data above calling fetchPairs \r\n        like below will return [ 1=>'Joe Blow', 2=>'Jack Doe', 3=>'Jane Doe'] \r\n        (NOTE: it uses the first two columns in the authors table; ie. author_id and name):\r\n     */\r\n    $data = $authors_model->fetchPairs();\r\n?>\r\n  ```\r\n\r\n* **Fetching data from one database table column into an array (via fetchCol):**\r\n  ```php\r\n<?php\r\n    $params = [\r\n        \"cols\"=>['name', 'date_created'],\r\n        'where' =>  [\r\n                        [ 'col'=>'author_id', 'op'=>'in', 'val'=>[1,3] ],\r\n                    ],\r\n    ];\r\n\r\n    //The $params array above causes any of the fetch* methods to generate the SQL \r\n    //statement below (which would be used by the fetch* method to retrieve data from the database):\r\n    /*\r\n        SELECT name, date_created\r\n          FROM `authors`\r\n         WHERE\r\n            (\r\n                author_id IN  (1,3)\r\n            );\r\n\r\n        ---------------------------------------------------------------------------\r\n        | author_id |     name    |       m_timestamp     |   date_created        |\r\n        ---------------------------------------------------------------------------\r\n        |     1     | 'Joe Blow'  | '2015-08-19 14:24:48' | '2015-08-19 14:24:48' |\r\n        ---------------------------------------------------------------------------\r\n        |     2     | 'Jack Doe'  | '2015-08-19 14:24:48' | '2015-08-19 14:24:48' |\r\n        ---------------------------------------------------------------------------\r\n        |     3     | 'Jane Doe'  | '2015-08-19 14:24:48' | '2015-08-19 14:24:48' |\r\n        ---------------------------------------------------------------------------\r\n      \r\n        Given an authors database table containing the data above calling fetchCol \r\n        like below will return ['Joe Blow', 'Jane Doe'] \r\n        (NOTE: it uses the first column in $params['cols']):\r\n     */\r\n    $data = $authors_model->fetchCol($params);\r\n\r\n    /*\r\n        Given an authors database table containing the data above calling fetchCol \r\n        like below will return [ 1, 2, 3] \r\n        (NOTE: it uses the first column in the authors table; ie. author_id):\r\n     */\r\n    $data = $authors_model->fetchCol();\r\n?>\r\n  ```\r\n\r\n* **Fetching data from a single row and column of a database table (via fetchValue):**\r\n  ```php\r\n<?php\r\n    $params = [\r\n        \"cols\"=>['name', 'date_created'],\r\n        'where' =>  [\r\n                        [ 'col'=>'author_id', 'op'=>'in', 'val'=>[1,3] ],\r\n                    ],\r\n    ];\r\n\r\n    //The $params array above causes any of the fetch* methods to generate the SQL \r\n    //statement below (which would be used by the fetch* method to retrieve data from the database):\r\n    /*\r\n        SELECT name, date_created\r\n          FROM `authors`\r\n         WHERE\r\n            (\r\n                author_id IN  (1,3)\r\n            );\r\n\r\n        ---------------------------------------------------------------------------\r\n        | author_id |     name    |       m_timestamp     |   date_created        |\r\n        ---------------------------------------------------------------------------\r\n        |     1     | 'Joe Blow'  | '2015-08-19 14:24:48' | '2015-08-19 14:24:48' |\r\n        ---------------------------------------------------------------------------\r\n        |     2     | 'Jack Doe'  | '2015-08-19 14:24:48' | '2015-08-19 14:24:48' |\r\n        ---------------------------------------------------------------------------\r\n        |     3     | 'Jane Doe'  | '2015-08-19 14:24:48' | '2015-08-19 14:24:48' |\r\n        ---------------------------------------------------------------------------\r\n      \r\n        Given an authors database table containing the data above calling fetchValue \r\n        like below will return 'Joe Blow'\r\n        (NOTE: it uses the value of first column in $params['cols'] in the first row of data returned):\r\n     */\r\n    $data = $authors_model->fetchValue($params);\r\n\r\n    /*\r\n        Given an authors database table containing the data above calling fetchValue \r\n        like below will return 1\r\n        (NOTE: it uses the value of first column in the authors table (ie. author_id) in the first row of data returned):\r\n     */\r\n    $data = $authors_model->fetchValue();\r\n?>\r\n  ```\r\n\r\n### Updating Data\r\nThere are two ways to update data in the database:\r\n\r\n1. By fetching one or more existing records from the database into record objects, then assigning new value(s) to each of the fetched records and then finally calling the **save** method on each Record object. If the records were fetched into a Collection object, then the **saveAll** method on the Collection object could be called instead (this will cause all the records in the collection to be saved).\r\n2. By calling the **updateMatchingDbTableRows** method on a Model object. This method does not involve the retrieval of Record objects, rather only the conditions for matching the rows of data in the database table to be updated and the new data to be used for the update need to be supplied to **updateMatchingDbTableRows**.\r\n  > Note: there is also an **updateSpecifiedRecord** method in the Model class which accepts a Record object as parameter and saves it to the database. The **updateSpecifiedRecord** method does not really need to be called, since the **save** method in the Record class calls it internally when **save** is called on a Record object that needs to be updated.\r\n\r\n  ```php\r\n<?php\r\n    //Method 1:\r\n    $params = [\r\n        'where' =>  [ [ 'col'=>'author_id', 'op'=>'=', 'val'=>2 ] ],\r\n    ];\r\n\r\n    //Fetch the first row of data with an author_id value of 2 from the authors \r\n    //table into a Record object.\r\n    $author_record = $authors_model->fetchOneRecord($params);\r\n    \r\n    //Change the value of a field in the fetched record.\r\n    $author_record->name = 'A new Name';\r\n    \r\n    //Save the change made to the Record object to the database.\r\n    $author_record->save();\r\n    \r\n    //NOTE: that the steps above can be applied to the Record objects returned  \r\n    //      by fetchRecordsIntoArray and fetchRecordsIntoCollection.\r\n    \r\n    //Method 2:\r\n    //Update all rows of data with an author_id value of 2 in the authors \r\n    //table, set the value of the name column in each of these rows to\r\n    //'Another new Name'.\r\n    $authors_model\r\n        ->updateMatchingDbTableRows(['name'=>'Another new Name'], ['author_id'=>2]);\r\n\r\n    //NOTE: updateMatchingDbTableRows only supports conditions using the equality operator ('=')\r\n    //      to match the rows to be updated. If you need to match rows using other operators like \r\n    //      >, <=, LIKE, etc. then use any of the fetch methods that return Record objects to fetch\r\n    //      the data you want to update and either call the save method on each Record object or call\r\n    //      the saveAll method on a Collection object containing the record objects. The fetch methods \r\n    //      allows you to specify more complex conditions for matching rows of data than \r\n    //      updateMatchingDbTableRows does.\r\n?>\r\n  ```\r\n\r\n### Deleting Data\r\nThere are two ways of deleting data from the database:\r\n\r\n1. By fetching one or more existing records from the database into record objects and then calling the **delete** method on each Record object (NOTE: the data is deleted from the database but the Record object still contains the data and is automatically marked as new. To make sure the data is both deleted from the database and cleared out of the Record object the **delete** method on the Record object must be called with a boolean value of true as its first parameter). If the records were fetched into a Collection object, then the **deleteAll** method on the Collection object could be called instead (this will cause all the records in the collection to be deleted from the database, but the Record objects will still be in the Collection object with their data intact. **removeAll** should additionally be called on the Collection object to clear the Record objects and their data from the Collection object; if the Record Objects are not referenced anywhere else outside of the Collection object, then the **__destruct** method will be automatically called on each Record object and all the memory used by the Record objects will be released).\r\n2. By calling the **deleteMatchingDbTableRows** method on a Model object. This method does not involve the retrieval of Record objects, rather only the conditions for matching the rows of data in the database table to be deleted needs to be supplied to **deleteMatchingDbTableRows**.\r\n  > Note: there is also a **deleteSpecifiedRecord** method in the Model class which accepts a Record object as parameter and deletes the database row associated with the Record object, sets the primary key value of the Record object to null and also sets the **_is_new** property of the Record object to the boolean value of true (NOTE: other data in the Record object remains). The **deleteSpecifiedRecord** method does not really need to be called, since the **delete** method in the Record class calls it internally when **delete** is called on a Record object that needs to be deleted.\r\n\r\n  ```php\r\n<?php\r\n    //Method 1:\r\n    $params = [\r\n        'where' =>  [ [ 'col'=>'author_id', 'op'=>'=', 'val'=>2 ] ],\r\n    ];\r\n\r\n    //Fetch the first row of data with an author_id value of 2 from the authors \r\n    //table into a Record object.\r\n    $author_record = $authors_model->fetchOneRecord($params);;\r\n    \r\n    //Delete the row corresponding to the Record object from the database.\r\n    $author_record->delete(); // OR $author_record->delete(true); to both delete from the database \r\n                              //and set the Record object's data to an empty array internally\r\n    \r\n    //NOTE: that the steps above can be applied to the Record objects returned  \r\n    //      by fetchRecordsIntoArray and fetchRecordsIntoCollection.\r\n    \r\n    //Method 2:\r\n    //Delete all rows of data with an author_id value of 2 in the authors \r\n    //table.\r\n    $authors_model->deleteMatchingDbTableRows(['author_id'=>2]);\r\n\r\n    //NOTE: deleteMatchingDbTableRows only supports conditions using the equality operator ('=')\r\n    //      to match the rows to be deleted. If you need to match rows using other operators like \r\n    //      >, <=, LIKE, etc. then use any of the fetch methods that return Record objects to fetch\r\n    //      the data you want to delete and either call the delete method on each Record object or call\r\n    //      the deleteAll method on a Collection object containing the record objects. The fetch methods \r\n    //      allow you to specify more complex conditions for matching rows of data than \r\n    //      deleteMatchingDbTableRows does.\r\n?>\r\n  ```\r\n\r\n### Support or Contact\r\nYada Yada Yada.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}